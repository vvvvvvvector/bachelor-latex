\documentclass[a4paper,12pt,oneside]{book}

\usepackage{biblatex}
\addbibresource{bibliography.bib} 

\usepackage{amsthm} % definicje

\theoremstyle{definition}
\newtheorem{definition}{Definicja}
\newtheorem*{formal}{Definicja formalna}

\usepackage{pdfpages}

\usepackage{indentfirst} % akapity

\usepackage{lipsum}

\usepackage{polski}
\usepackage[T1]{fontenc}

\usepackage[pdftex,
            left=1in,right=1in,
            top=1in,bottom=1in]{geometry}

\usepackage{fancyhdr} % headers

\pagestyle{fancy}
\renewcommand{\sectionmark}[1]{\markright{\thesection\ #1}}
\fancyhead{}
\fancyhead[HR]{\thepage}
\fancyhead[HL]{\rightmark}
\setlength{\headheight}{15pt}
\fancyfoot{}

\begin{document}

\includepdf{titlepage.pdf}

\tableofcontents{}

\chapter*{Wstęp}
\addcontentsline{toc}{chapter}{Wstęp}

 Graficzny interfejs użytkownika (ang. graphical user interface, \textbf{GUI}) jest typem interfejsu za pomocą którego użytkownik wchodzi w interakcję z komputerem, programem. Dobrze przemyślony, wygodny, niezawodny, pomagający użytkownikowi interfejs napewno poszerza grono użytkowników aplikacji, co może m.in dobrze wpłynąć na rozwój biznesu lub suksec twórcy. Wyobraźmy, na przykład, co by było gdyby systemy operacyjne nie miały interfejsów graficznych? Brak interfejsu bardzo podwyższa poziom przygotowania dla korzystania z takiej / takiego aplikacji / programu. Interfejsy, w większości, robią skomplikowane programy dostępnymi dla wielu ludzi. Niskopoziomowe staje się wysokopoziomowym. Interfejsy graficzne są bardzo ważną częścią każdej aplikacji. Często patrząc tylko na wizualny wygląd już nie chce z niej korzytać. To jest źle, dla niektórych użytkowników to może być bardzo krytyczne i oni pójdą szukać inne rozwiązania, szkoda, bo ze względu na funkcjonalność aplikacja może być bardzo bogata. Dlatego jest bardzo ważne dbać o to, żeby aplikacja była nie tylko funkcjonalna, ale i nie było lagów, była atrakcyjna, wygodna, dostępna.

\chapter{Wprowadzenie}

\section{CNF}

\begin{definition}[CNF]
     Koniunkcyjna postać normalna (ang. conjunctive normal form) danej formuły logicznej to równoważna jej formuła zapisana w postaci koniunkcji klauzul. Klauzula jest zbiorem literałów połączonych alternatywą. Literałem nazywamy pojedynczą zmienną zdaniową lub pojedynczą zanegowaną zmienną zdaniową. Zmienna zdaniowa to zmienna która może przyjmować wartość \textit{true} lub \textit{false} 
\end{definition}

Przykład klauzuli:

\begin{center}
    $(x \lor y \lor z)$. 
\end{center}

Przykłady literałów:

\begin{center}
    $p, q, \neg p$
\end{center}

\begin{formal}
    Formuła $\psi$ jest w koniunkcyjnej postaci normalnej jeśli jest ona koniunkcją klauzul, z których każda jest alternatywą \textit{literałów}, tzn. ma następującą postać: 
    \begin{center}
    $(p_{11} \lor p_{12} \lor \ldots \lor p_{1{k_1}}) \land (p_{21} \lor p_{22} \lor \ldots \lor p_{2{k_2}}) \land \ldots \land (p_{n1} \lor p_{n2} \lor \ldots \lor p_{n{k_n}})$
    \end{center}
    gdzie każde $p_{ij}$ jest literałem.
\end{formal}

Każdą formułę logiczną można przedstawić równoważnie w postaci CNF. Dla jednej formuły logicznej może istnieć kilka równoważnych jej formuł w CNF.  

\section{Problem spełnialności formuł logicznych}

\textbf{Problem spełnialności formuł logicznych} jest ważym problemem obliczeniowym w teorii złożoności. Wejściem problemu jest formuła logiczna w postaci CNF. Problem polega na znalezieniu wartościowania, tzn. wartości wszystkich zmiennych zdaniowych, takich, kiedy formuła staje się prawdziwa. Formułę, która posiada takie wartościowanie nazywamy formułą \textit{spełnialną} (ang. satisfiable), a która nie, odpowiednio \textit{niespełnialna} (ang. unsatisfiable).

Na przykład, formuła
\begin{center}
    $(x_1 \lor \neg x_3) \land (x_2 \lor x_3 \lor \neg x_1)$
\end{center}

jest spełnialna, dlatego, że istnieje wartościowanie które ją spełnia, np.:
\begin{center}
    $x_1 = false, x_2 = false, x_3 = false$
\end{center}

Problem SAT jest pierwszym problemem którego NP-zupełność wykazano, to jest \textbf{Twierdzenie Cooka-Levina}.

\section{SAT-solvery}

\textbf{SAT-solver} jest programem mający na celu rozwiązanie problemu spełnialności. Na wejściu program przyjmuje formulę w postaci CNF, a na wyjściu zwraca odpowiedź, czy podana formuła jest lub nie jest spełnialna. Oryginalny SAT-solver wymaga spełnienia \textbf{wszystkich} klauzul.

Większość SAT-solverów zwraca nie tylko informację o spełnialności, ale też przykładowe wartościowanie, jeśli formuła była spełnialna, lub minimalny zbiór niespełnialnych klauzul, jeśli formuła była niespełnialna.

SAT-solvery mają wiele udanych zastosowań w różnych dziedzinach, takich jak np. sztuczna inteligencja, automatyzacja projektowania elektronicznego (ang. Electronic Design Automation), analiza programów.

Istnieją różne rodzaje SAT-solverów, które rozwiązują inne odmiany problemu spełnialności formuł logicznych: 

\begin{itemize}
    \item MAX-SAT - szuka maksymalnej liczby klauzul, które mogą być spełnione, tzn. zadajemy pytanie ile maksumalnie klauzul z tej formuły dadzą formułę spełnialną jeśli połączymy je razem.
    \item Częściowy MAX-SAT (ang. Partial MAX-SAT) - podczas gdy klasyczny problem SAT wymaga spełnienia wszystkich klauzul, PM-SAT jest rozluźniony spełnienia tego wymogu poprzez oznaczenie niektórych klauzul jako miękkie (ang. soft), a innych jako twarde (ang. hard). Celem jest znalezienie wartościowania, które spełnia wszystkie klauzule twarde i maksymalizuje liczbę spełnionych klauzul miękkich.

\end{itemize}

\section{Format DIMACS CNF}

DIMACS CNF to format tekstowy reprezentujący formułę w koniunkcyjnej postaci normalnej. Pliki z formułami mogą być w dowolnym formacie tekstowym, ale najczęściej stosują się *.cnf lub *.txt. 

Reguły których trzeba pilnować, żeby poprawnie stworzyć plik z formułą: 

\begin{enumerate}
    \item Linie zaczynające się od znaku \textit{c} przedstawiają komentarze.
    \item Linia zaczynająca się od znaku \textit{p} jest definicją formuły i wygląda następująco: \textit{p cnf l k}. Gdzie \textit{l} i \textit{k} są liczbami dodatnimi, gdzie \textit{l} reprezentuje liczbę zmiennych formuły, a \textit{k} reprezentuję liczbę klauzul.
    \item Klauzule są umieszczane dokładnie po definicji formuły. Każda klauzula jest zakodowana jako sekwencja liczb dziesiętnych odseparowanymi spacjami.
    \item Każda linia zawiera dokładnie jedną klauzulę i ma kończyć się symbolem 0.
    \item Zostawianie pustych linii w formule nie jest dozwolone.
\end{enumerate}
Niepilnowanie tych reguł może doprowadzić do błędnych wyników lub w ogóle do unieruchomienia SAT-solvera.

Na przykład formuła w CNF

\begin{center}
    $(x_1 \lor x_2 \lor x_3 \lor x_4) \land (\neg x_1 \lor x_2) \land (x_3 \lor x_4 \lor \neg x_1) \land (x_2 \lor x_3 \lor \neg x_1)$ 
\end{center}

może być zakodowana w DIMACS CNF jako:

\begin{verbatim}
                                p cnf 4 4
                                1 2 3 4 0
                                -1 2 0
                                3 4 -1 0
                                2 3 -1 0
\end{verbatim}

\section{Cel i zakres pracy}

Celem pracy jest stworzenie wygodnego i dostępnego dla wszystkich interfejsu graficznego dla oryginalnego SAT-solvera. Dostępność zapewnijmy tworząc aplikację webową dlatego, że nie wymaga od użytkownika żadnych nipotrzebnych instalacji, działa prawie wszędzie i dla uruchomienia potrzebny jest tylko komputer i internet. Wygodność zapewnijmy przemyślonym interfejsem, który będzie w razie problemów pomagał użytkownikowi w ich rozwiązaniu za pomocą odpowiednich komunikatów i sugestii. W pracy zostanie omówniony proces projektowania interfejsu oraz szczegóły implementacji niektórych, najbardziej interesujących części aplikacji. 

Frontend będzie stworzony za pomocą biblioteki \textbf{React}, a backend za pomocą frameworku \textbf{FastAPI}. Na backendzie wykorzystamy pakiet \textbf{PySAT}, który daję możliwość korzystania z wielu zaimplementowanych SAT-solverów. Komunikację pomiędzy backendem a frontendem zapewnijmy poprzez HTTP zapytania.

\chapter{Projekt}

\section{Definicja funkcjonalności}

Wygląd aplikacji mocno zależy od tego, jak zdefiniujemy funkcjonalności, więc:  

\begin{itemize}
    \item parsowanie formuły z pliku w formacie DIMACS CNF do CNF
    \item możliwość edycji formuły w postaci CNF
    \item wyświetlanie w wygodny sposób formuł w postaci CNF (dzielenie dużych formuł na strony; wyświetlanie tylko odpowiedniej ilości klauzul na jednej stronie)
    \item formuła w postaci CNF dostaje możliwość edycji, czyli można: modyfikować, usuwać, dodawać klauzule
    \item kiedy zmienia się formuła w postaci CNF, zmienia się jednocześnie formuła w DIMACS CNF w edytorze
    \item wczytywanie formuł z pliku
    \item zapisywanie formuły w formacie DIMACS CNF do pliku
    \item wyświetlanie w wygodny sposób dużych wartościowań spełniających formułę
    \item poprawianie automatyczne formuły (na końcach linii są dopisywane zera, liczby zmiennych i klauzul w nagłówku są poprawiane na odpowiednie, puste linie są usuwane, niepoprawne klauzule są usuwane)
    \item wyświetlanie ilości znalezionych rozwiązań
    \item zapisywanie pojedynczego wartościowania w postaci ``binarnej''
    \item możliwość znalezienia i wyświetlenia pojedynczego wartościowania spełniającego formułę
    \item możliwość znalezienia i wyświetlenia wszystkich wartościowań spełniających
    \item usuwanie zduplikowanych klauzul z formuły
    \item możliwość lączenia dwóch formuł w jedną, co z kolei daje możliwość lączenia dowolnej ilości formuł
    \item edytor DIMACSów: sprawdzanie poprawności edytowanych plików
    \item edytor DIMACSów: wszkazuwanie błędów. Kody błędów z opisem 0 -> ('no empty lines allowed'), 1 -> ('invalid formula definition'), 2 -> ('clause must end with 0'), 3 -> ('invalid clause'), 4 -> (`formula was already defined in line formulaDefinitionRow.current), 5 -> (`Wrong variable value: varError => range[1..rangeInDef]`)
    \item edytor DIMACSów: edytor, w razie błedów w formule, daje użytkownikowi indywidualne do każdego błędu sugestie do poprawienia
\end{itemize}

\section{Prototypowanie interfejsu}

\lipsum[1]

\lipsum[2]

\lipsum[3]

\section{Architektura aplikacji}

\lipsum[1]

\lipsum[2]

\lipsum[3]

\chapter{Implementacja}

\section{Narzędzia}

\subsection{PySAT}

\lipsum[1]

\lipsum[2]

\lipsum[3]

\subsection{FastAPI}

\lipsum[1]

\lipsum[2]

\lipsum[3]

\subsection{React}

\lipsum[1]

\lipsum[2]

\lipsum[3]

\section{Implementaja edytora}

\lipsum[1]

\lipsum[2]

\lipsum[3]

\section{Implementacja sprawdzarki}

\lipsum[1]

\lipsum[2]

\lipsum[3]

\section{Optymalizacje}

\lipsum[1]

\lipsum[2]

\lipsum[3]

\lipsum[4]

\chapter*{Podsumowanie}
\addcontentsline{toc}{chapter}{Podsumowanie}

Ja chcę, żeby mój program stał się początkiem tworzenia interfejsów graficznych dla różnych rodzajów SAT-solverów. Ze względu na brak takich programów. W mojej pracy dotknąłem tylko mało część, dużo rzeczy można jeszcze do tego dodać.

Będę \cite{einstein} zawsze otwarty na takie propozycję na GitHubie. Chciałbym, żeby \cite{dirac} studenci naszej uczelni w \cite{dirac} swoich pracach licencjackich lub \cite{knuthwebsite} nawet magisterskich \cite{knuth-fa} kontynuowali rozwijanie i polepszenie mojego programu.

\printbibliography[title=Bibliografia]

\addcontentsline{toc}{chapter}{Bibliografia}

\end{document}
